<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Golf Ball Tracker v2</title>
<style>
:root {
  --black: #0c0c0c;
  --red: #e7222a;
  --darkred: #ba1e1e;
  --green: #00ff88;
  --orange: #ff9500;
  --safe-top: env(safe-area-inset-top);
  --safe-bottom: env(safe-area-inset-bottom);
  --safe-left: env(safe-area-inset-left);
  --safe-right: env(safe-area-inset-right);
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body {
  background: var(--black);
  color: #fff;
  font-family: system-ui, -apple-system, sans-serif;
  height: 100%;
  overflow: hidden;
  touch-action: manipulation;
}
#wrap {
  position: fixed;
  inset: 0;
  background: var(--black);
}
video, #overlay {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
#overlay { pointer-events: none; }

/* ── STATUS BADGE ── */
#status {
position: absolute;
top: calc(14px + var(–safe-top));
left: calc(14px + var(–safe-left));
background: rgba(20,20,20,0.92);
border: 1px solid rgba(255,255,255,0.1);
border-radius: 10px;
padding: 10px 14px;
font-size: 12px;
font-weight: 700;
white-space: pre-line;
line-height: 1.5;
z-index: 20;
max-width: 220px;
}

/* ── EXPOSURE HINT ── */
#exposureHint {
position: absolute;
top: calc(14px + var(–safe-top));
right: calc(14px + var(–safe-right));
background: rgba(231,34,42,0.15);
border: 1px solid rgba(231,34,42,0.4);
border-radius: 10px;
padding: 10px 14px;
font-size: 11px;
font-weight: 700;
line-height: 1.6;
z-index: 20;
display: none;
}
#exposureHint.show { display: block; }

/* ── METRICS ── */
#metrics {
position: absolute;
top: calc(14px + var(–safe-top));
right: calc(14px + var(–safe-right));
background: rgba(20,20,20,0.92);
border: 1px solid rgba(255,255,255,0.1);
border-radius: 10px;
padding: 12px 14px;
z-index: 20;
display: none;
min-width: 170px;
}
#metrics.show { display: block; }
.mrow {
display: flex;
justify-content: space-between;
align-items: baseline;
gap: 12px;
margin-bottom: 7px;
}
.mrow:last-child { margin-bottom: 0; }
.mlabel {
font-size: 9px;
font-weight: 800;
text-transform: uppercase;
letter-spacing: .1em;
color: rgba(255,255,255,0.5);
}
.mval {
font-size: 15px;
font-weight: 900;
font-variant-numeric: tabular-nums;
color: #fff;
}
.mval.green { color: var(–green); }
.mval.orange { color: var(–orange); }

/* ── BUTTONS ── */
.btn {
position: absolute;
left: 50%;
transform: translateX(-50%);
border: none;
font-size: 14px;
font-weight: 800;
letter-spacing: .4px;
text-transform: uppercase;
padding: 13px 28px;
border-radius: 999px;
cursor: pointer;
z-index: 100;
pointer-events: auto;
transition: opacity .15s, transform .15s;
white-space: nowrap;
}
.btn:active:not(:disabled) { transform: translateX(-50%) scale(0.97); }
.btn:disabled { opacity: .35; cursor: not-allowed; }
.btn-primary {
background: linear-gradient(135deg, var(–red), var(–darkred));
color: #fff;
box-shadow: 0 4px 20px rgba(231,34,42,.4);
bottom: calc(20px + var(–safe-bottom));
}
.btn-ghost {
background: rgba(30,30,30,0.92);
border: 1px solid rgba(255,255,255,.12);
color: #fff;
}
#btnCamera   { bottom: calc(20px + var(–safe-bottom)); }
#btnRef      { bottom: calc(76px + var(–safe-bottom)); }
#btnTrack    { bottom: calc(132px + var(–safe-bottom)); }
#btnReset    { bottom: calc(188px + var(–safe-bottom)); }

/* ── BRIGHTNESS SLIDER ── */
#brightnessControl {
position: absolute;
bottom: calc(250px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
display: none;
flex-direction: column;
align-items: center;
gap: 6px;
z-index: 100;
background: rgba(20,20,20,0.9);
border: 1px solid rgba(255,255,255,.1);
border-radius: 12px;
padding: 12px 20px;
width: 260px;
}
#brightnessControl.show { display: flex; }
#brightnessControl label {
font-size: 11px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: .1em;
color: rgba(255,255,255,.6);
}
#brightnessSlider {
width: 100%;
accent-color: var(–red);
}
#brightnessValue {
font-size: 12px;
font-weight: 800;
color: var(–orange);
}

/* ── TOAST ── */
.toast {
position: fixed;
bottom: calc(300px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
background: rgba(20,20,20,.96);
border: 1px solid var(–red);
border-radius: 10px;
padding: 10px 18px;
font-size: 13px;
font-weight: 700;
z-index: 1000;
pointer-events: none;
animation: slideUp .25s ease-out;
}
@keyframes slideUp {
from { opacity:0; transform: translate(-50%,14px); }
to   { opacity:1; transform: translate(-50%,0); }
}

/* ── DEBUG CANVAS BRIGHTNESS WARNING ── */
#darkWarning {
position: absolute;
bottom: calc(310px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
background: rgba(255,149,0,.2);
border: 1px solid var(–orange);
border-radius: 8px;
padding: 8px 16px;
font-size: 11px;
font-weight: 700;
color: var(–orange);
z-index: 20;
display: none;
white-space: nowrap;
}
#darkWarning.show { display: block; }
</style>

</head>
<body>
<div id="wrap">
  <video id="video" playsinline autoplay muted></video>
  <canvas id="overlay"></canvas>

  <div id="status">Press START CAMERA</div>
  <div id="exposureHint" class="show">
    ⚠️ IMAGE TOO DARK?<br>
    This app uses a very high<br>
    shutter speed. You need<br>
    BRIGHT LED lights.<br>
    Use the slider below ↓
  </div>

  <div id="metrics">
    <div class="mrow"><span class="mlabel">FRAMES</span><span class="mval" id="mFrames">0</span></div>
    <div class="mrow"><span class="mlabel">BALL SPEED</span><span class="mval green" id="mSpeed">--</span></div>
    <div class="mrow"><span class="mlabel">ANGLE</span><span class="mval" id="mAngle">--</span></div>
    <div class="mrow"><span class="mlabel">DIRECTION</span><span class="mval orange" id="mDir">--</span></div>
    <div class="mrow"><span class="mlabel">DEVIATION</span><span class="mval" id="mDev">--</span></div>
  </div>

  <div id="darkWarning">⚠️ Frame too dark — increase lighting</div>

  <div id="brightnessControl">
    <label>Exposure Compensation</label>
    <input id="brightnessSlider" type="range" min="-3" max="0" step="0.25" value="-2"/>
    <span id="brightnessValue">-2.0 EV (high shutter)</span>
  </div>

<button class="btn btn-primary" id="btnCamera">Start Camera</button>
<button class="btn btn-ghost" id="btnRef"   disabled>Capture Reference</button>
<button class="btn btn-ghost" id="btnTrack" disabled>Start Tracking</button>
<button class="btn btn-ghost" id="btnReset" disabled>Reset</button>

</div>

<script>
/* ═══════════════════════════════════════════
   THE KEY INSIGHT:
   Use a very high shutter speed to track
   golf balls. This results in a darker image
   but freezes the ball perfectly in each frame.

   High shutter speed = frozen ball with zero
   motion blur in every single 60fps frame.
   The ball is crisp and circular in each frame
   it appears in — making blob detection reliable.

   Without this, at high speeds the ball becomes
   a long blur smear that fails circularity checks.
═══════════════════════════════════════════ */

/* ─── CONFIG ─── */
const CFG = {
  // Detection thresholds
  DIFF_THR:       25,    // lower = more sensitive (ball may be slightly diff shade)
  MIN_BLOB:       8,     // min connected pixels in downsampled grid
  MAX_BLOB:       3000,
  MIN_R_PX:       5,     // min ball radius in pixels
  MAX_R_PX:       80,    // larger for top-down view
  MAX_ASPECT:     1.8,   // allow slightly non-circular (top-down angle)
  STEP:           2,     // sampling step — smaller = more accurate, slower

  // Pre-impact
  STABLE_FRAMES:  6,     // frames ball must be still to be "locked"
  STABLE_THRESH:  4,     // max pixel movement to count as stable
  IMPACT_THRESH:  18,    // pixels of movement = impact detected

  // Post-impact
  MAX_POST_FRAMES: 12,   // max frames to track after impact
  MAX_MISSED:      4,    // frames without detection before giving up
  SEARCH_RADIUS:   350,  // px around last known position

  // Physics
  PX_PER_METER:   null,  // set during calibration, or estimated from ball size
  BALL_DIAMETER_M: 0.0427, // real golf ball diameter in metres
};

/* ─── STATE ─── */
const S = {
  IDLE: 0, WAITING_BALL: 1, BALL_LOCKED: 2,
  IMPACT: 3, TRACKING: 4, DONE: 5
};
let state = S.IDLE;
let refFrame = null;
let preFrames  = [];   // {x,y,r,t}
let postFrames = [];
let stableCount = 0;
let lockedPos   = null; // {x,y,r}
let lastPos     = null;
let missedCount = 0;
let loopId      = null;
let exposureEV  = -2.0; // default: very fast shutter

/* ─── DOM ─── */
const video    = document.getElementById('video');
const overlay  = document.getElementById('overlay');
const ctx      = overlay.getContext('2d', {willReadFrequently:true});
const offscreen = document.createElement('canvas');
const offCtx   = offscreen.getContext('2d', {willReadFrequently:true});

const status   = document.getElementById('status');
const metrics  = document.getElementById('metrics');
const darkWarn = document.getElementById('darkWarning');
const expCtrl  = document.getElementById('brightnessControl');
const expSlider = document.getElementById('brightnessSlider');
const expVal   = document.getElementById('brightnessValue');

/* ─── HELPERS ─── */
function toast(msg) {
  document.querySelectorAll('.toast').forEach(e=>e.remove());
  const t = document.createElement('div');
  t.className = 'toast'; t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(()=>t.remove(), 3000);
}
function setStatus(t) { status.textContent = t; }
function setMetric(id, v) { document.getElementById(id).textContent = v; }

/* ─── WHITE-BALL DETECTOR ─── 
   Works for both standard and high-shutter (darker) frames.
   At high shutter speed, white ball still appears bright
   relative to the (now darker) background.
   We check absolute brightness AND relative brightness. */
function isBallPixel(r, g, b, backgroundBrightness) {
  const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
  const chroma = Math.max(r,g,b) - Math.min(r,g,b);
  // Must be white-ish (low saturation)
  if (chroma > 45) return false;
  // Absolute: must be reasonably bright
  if (brightness < 140) return false;
  return true;
}

/* ─── GRAB FRAME ─── */
function grabFrame() {
  offCtx.drawImage(video, 0, 0);
  return offCtx.getImageData(0, 0, offscreen.width, offscreen.height);
}

/* ─── CHECK FRAME BRIGHTNESS ─── 
   Warn user if overall frame is too dark to detect */
function checkBrightness(frame) {
  let sum = 0;
  const step = 20;
  let count = 0;
  for (let i = 0; i < frame.data.length; i += step*4) {
    sum += (frame.data[i] + frame.data[i+1] + frame.data[i+2]) / 3;
    count++;
  }
  const avg = sum / count;
  darkWarn.classList.toggle('show', avg < 30);
  return avg;
}

/* ─── BLOB DETECTION ─── */
function findBall(refFrame, curFrame, x0, x1, y0, y1, prevPos) {
  const w = curFrame.width;
  const step = CFG.STEP;
  x0 = Math.max(0, x0|0);  x1 = Math.min(w, x1|0);
  y0 = Math.max(0, y0|0);  y1 = Math.min(curFrame.height, y1|0);

  const gw = Math.max(1, ((x1-x0)/step)|0);
  const gh = Math.max(1, ((y1-y0)/step)|0);
  const grid = new Uint8Array(gw * gh);

  /* diff + white check */
  let idx = 0;
  for (let gy = 0; gy < gh; gy++) {
    const ay = y0 + gy*step;
    for (let gx = 0; gx < gw; gx++, idx++) {
      const ax = x0 + gx*step;
      const fi = (ay*w + ax)*4;
      const cr=curFrame.data[fi], cg=curFrame.data[fi+1], cb=curFrame.data[fi+2];
      const dr=Math.abs(cr-refFrame.data[fi]);
      const dg=Math.abs(cg-refFrame.data[fi+1]);
      const db=Math.abs(cb-refFrame.data[fi+2]);
      if ((dr+dg+db)/3 > CFG.DIFF_THR && isBallPixel(cr,cg,cb)) grid[idx]=1;
    }
  }

  /* connected components */
  const vis = new Uint8Array(gw*gh);
  let best = null, bestScore = 0;

  for (let i = 0; i < grid.length; i++) {
    if (!grid[i] || vis[i]) continue;
    const q=[i]; vis[i]=1; const comp=[];
    for (let qi=0; qi<q.length; qi++) {
      const c=q[qi]; comp.push(c);
      const gx=c%gw, gy=(c/gw)|0;
      const ns=[c-1,c+1,c-gw,c+gw];
      const ok=[gx>0,gx<gw-1,gy>0,gy<gh-1];
      for (let n=0;n<4;n++) if(ok[n]&&grid[ns[n]]&&!vis[ns[n]]){vis[ns[n]]=1;q.push(ns[n]);}
    }
    if (comp.length<CFG.MIN_BLOB||comp.length>CFG.MAX_BLOB) continue;

    let sx=0,sy=0,mnx=Infinity,mxx=-Infinity,mny=Infinity,mxy=-Infinity;
    for (const c of comp) {
      const gx=c%gw,gy=(c/gw)|0;
      sx+=gx;sy+=gy;
      if(gx<mnx)mnx=gx;if(gx>mxx)mxx=gx;
      if(gy<mny)mny=gy;if(gy>mxy)mxy=gy;
    }
    const cx=x0+(sx/comp.length)*step;
    const cy=y0+(sy/comp.length)*step;
    const bw=(mxx-mnx+1)*step, bh=(mxy-mny+1)*step;
    const radius=Math.max(bw,bh)/2;
    if (radius<CFG.MIN_R_PX||radius>CFG.MAX_R_PX) continue;
    const aspect=bw>=bh?bw/bh:bh/bw;
    if (aspect>CFG.MAX_ASPECT) continue;

    let score = comp.length * (comp.length/(bw*bh));
    // Bias toward previous position when tracking
    if (prevPos) {
      const dx=cx-prevPos.x, dy=cy-prevPos.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      score /= (1 + dist*0.015);
      if (prevPos.r) score /= (1+Math.abs(radius-prevPos.r)*0.08);
    }
    if (score>bestScore) { bestScore=score; best={x:cx,y:cy,r:radius}; }
  }
  return best;
}

/* ─── APPLY EXPOSURE CONTROL ─── 
   Key technique: set low exposureCompensation
   which forces very fast shutter speed = frozen ball. */
let imageCapture = null;
async function applyExposure(ev) {
  exposureEV = ev;
  expVal.textContent = `${ev.toFixed(2)} EV (${ev <= -1.5 ? 'fast shutter ✓' : 'normal'})`;
  
  if (!imageCapture) return;
  try {
    const capabilities = await imageCapture.getPhotoCapabilities();
    const settings = {};
    
    // Try ImageCapture exposure compensation
    if (capabilities.exposureCompensation) {
      const {min,max} = capabilities.exposureCompensation;
      // Map our EV scale (-3 to 0) to device range
      const mapped = min + ((ev + 3) / 3) * (max - min);
      settings.exposureCompensation = Math.max(min, Math.min(max, mapped));
    }
    
    await imageCapture.setOptions(settings);
  } catch(e) {
    // ImageCapture exposure not supported on all devices
    // Fall back to constraintApply on the track
    try {
      const track = video.srcObject?.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        await track.applyConstraints({
          advanced: [{ exposureCompensation: ev }]
        });
      }
    } catch(e2) { /* silent */ }
  }
}

/* ─── CAMERA START ─── */
async function startCamera() {
  try {
    const perm = await navigator.mediaDevices.getUserMedia({video:true});
    perm.getTracks().forEach(t=>t.stop());

    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
    const back = cams.find(d=>/back|rear|environment/i.test(d.label));
    const usb  = cams.find(d=>/usb|uvc|capture|hdmi|elgato/i.test(d.label));

    const deviceId = (usb||back)?.deviceId;
    const constraints = {
      video: {
        ...(deviceId ? {deviceId:{exact:deviceId}} : {facingMode:{ideal:'environment'}}),
        width:  {ideal:1920},
        height: {ideal:1080},
        frameRate: {ideal:60},
        // Request manual exposure mode so we can set shutter speed
        exposureMode: 'manual',
        // Key: very low exposure compensation = very fast shutter = frozen ball
        exposureCompensation: {ideal: -2.0},
        // Also try to lock white balance so reference frame stays valid
        whiteBalanceMode: 'continuous',
      }
    };

    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();

    await new Promise(r => {
      if (video.videoWidth) return r();
      video.addEventListener('loadedmetadata', r, {once:true});
    });
    overlay.width = offscreen.width = video.videoWidth;
    overlay.height = offscreen.height = video.videoHeight;

    // Set up ImageCapture for fine exposure control
    const track = stream.getVideoTracks()[0];
    if (window.ImageCapture) {
      imageCapture = new ImageCapture(track);
    }

    // Log actual camera settings
    const settings = track.getSettings();
    console.log('Camera settings:', settings);
    console.log('Actual FPS:', settings.frameRate);
    console.log('Exposure mode:', settings.exposureMode);
    console.log('Exposure compensation:', settings.exposureCompensation);

    setStatus(`Camera ready\n${settings.frameRate|0}fps · ${video.videoWidth}×${video.videoHeight}`);
    document.getElementById('btnCamera').disabled = true;
    document.getElementById('btnRef').disabled = false;
    expCtrl.classList.add('show');
    document.getElementById('exposureHint').classList.remove('show');

    applyExposure(parseFloat(expSlider.value));
    toast('Camera started — adjust exposure if needed');
  } catch(err) {
    console.error(err);
    setStatus('Camera error:\n'+err.message);
    toast('Camera failed: '+err.message);
  }
}

/* ─── REFERENCE CAPTURE ─── */
function captureReference() {
  refFrame = grabFrame();
  const avgBrightness = checkBrightness(refFrame);
  
  state = S.WAITING_BALL;
  preFrames = []; postFrames = [];
  stableCount = 0; lockedPos = null;

  setStatus(`Ref captured\nBrightness: ${avgBrightness.toFixed(0)}\nPlace ball in view`);
  document.getElementById('btnTrack').disabled = false;
  document.getElementById('btnReset').disabled = false;
  
  if (avgBrightness < 40) {
    toast('⚠️ Dark image! Add more light for better detection');
  } else {
    toast('Reference captured — place ball & hit');
  }
}

/* ─── START TRACKING ─── */
function startTracking() {
  if (!refFrame) return;
  state = S.WAITING_BALL;
  preFrames = []; postFrames = [];
  stableCount = 0; lockedPos = null; lastPos = null; missedCount = 0;
  metrics.classList.add('show');
  document.getElementById('btnTrack').disabled = true;
  document.getElementById('btnRef').disabled = true;
  setStatus('Waiting for ball...\nPlace ball in frame');
  setMetric('mFrames','0'); setMetric('mSpeed','--');
  setMetric('mAngle','--'); setMetric('mDir','--');
  setMetric('mDev','--');
  scheduleNext();
}

/* ─── MAIN PROCESSING LOOP ─── */
function scheduleNext() {
  if (state===S.IDLE||state===S.DONE) return;
  if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
    loopId = video.requestVideoFrameCallback(onFrame);
  } else {
    loopId = requestAnimationFrame(onFrame);
  }
}

function onFrame() {
  if (state===S.IDLE||state===S.DONE) return;
  processFrame();
  scheduleNext();
}

function processFrame() {
  if (!refFrame) return;
  const cur = grabFrame();
  checkBrightness(cur);
  const W = cur.width, H = cur.height;
  const t = performance.now();

  if (state === S.WAITING_BALL || state === S.BALL_LOCKED) {
    /* Search a generous region for the stationary ball */
    const ball = findBall(refFrame, cur, 0, W, 0, H, lockedPos);

    if (ball) {
      /* Check stability */
      if (lockedPos) {
        const dx=ball.x-lockedPos.x, dy=ball.y-lockedPos.y;
        const moved=Math.sqrt(dx*dx+dy*dy);

        if (moved < CFG.STABLE_THRESH) {
          stableCount++;
        } else if (moved > CFG.IMPACT_THRESH && stableCount >= CFG.STABLE_FRAMES) {
          /* ─── IMPACT! ─── */
          state = S.TRACKING;
          postFrames = [{x:ball.x,y:ball.y,r:ball.r,t}];
          lastPos = ball;
          missedCount = 0;
          setStatus('Impact! Tracking...');
          toast('Impact detected!');
          setMetric('mFrames','1');
          
          // Calibrate px/m from locked ball size if not set
          if (!CFG.PX_PER_METER && lockedPos) {
            CFG.PX_PER_METER = (lockedPos.r * 2) / CFG.BALL_DIAMETER_M;
            console.log(`Auto-calibrated: ${CFG.PX_PER_METER.toFixed(0)} px/m from ball radius ${lockedPos.r.toFixed(1)}px`);
          }
          return;
        } else {
          stableCount = Math.max(0, stableCount - 1);
        }
      }

      lockedPos = ball;
      preFrames.push({x:ball.x,y:ball.y,r:ball.r,t});
      if (preFrames.length > 30) preFrames.shift();

      if (stableCount >= CFG.STABLE_FRAMES) {
        state = S.BALL_LOCKED;
        setStatus(`Ball locked ✓\nRadius: ${ball.r.toFixed(1)}px\nReady to hit!`);
      } else {
        setStatus(`Stabilizing...\n${stableCount}/${CFG.STABLE_FRAMES} frames`);
      }
    } else {
      stableCount = 0;
      setStatus('No ball detected\nPlace white ball in view');
    }

  } else if (state === S.TRACKING) {
    /* Search around last known position */
    const sr = CFG.SEARCH_RADIUS;
    const x0 = lastPos ? lastPos.x - sr : 0;
    const x1 = lastPos ? lastPos.x + sr : W;
    const y0 = lastPos ? lastPos.y - sr : 0;
    const y1 = lastPos ? lastPos.y + sr : H;

    const ball = findBall(refFrame, cur, x0, x1, y0, y1, lastPos);

    if (ball) {
      missedCount = 0;
      lastPos = ball;
      postFrames.push({x:ball.x,y:ball.y,r:ball.r,t});
      setMetric('mFrames', postFrames.length);
      if (postFrames.length >= 2) updateMetrics();
    } else {
      missedCount++;
      if (missedCount > CFG.MAX_MISSED) {
        finishTracking();
        return;
      }
    }

    if (postFrames.length >= CFG.MAX_POST_FRAMES) {
      finishTracking();
    }
  }
}

/* ─── FINISH & COMPUTE ─── */
function finishTracking() {
  state = S.DONE;
  updateMetrics();
  setStatus(`Done — ${postFrames.length} frames\nPress RESET for next shot`);
  toast('Shot tracked! See metrics →');
  document.getElementById('btnRef').disabled = false;
}

function updateMetrics() {
  if (postFrames.length < 2) return;

  const f0 = postFrames[0];
  const fN = postFrames[postFrames.length-1];

  /* velocity from all frames (linear regression for robustness) */
  let sumT=0,sumX=0,sumY=0,sumT2=0,sumTX=0,sumTY=0;
  const n = postFrames.length;
  const t0 = postFrames[0].t;
  for (const f of postFrames) {
    const dt = (f.t-t0)/1000;
    sumT+=dt; sumX+=f.x; sumY+=f.y;
    sumT2+=dt*dt; sumTX+=dt*f.x; sumTY+=dt*f.y;
  }
  const denom = n*sumT2 - sumT*sumT;
  let vxPxPerSec=0, vyPxPerSec=0;
  if (Math.abs(denom)>1e-9) {
    vxPxPerSec = (n*sumTX - sumT*sumX) / denom;
    vyPxPerSec = (n*sumTY - sumT*sumY) / denom;
  }

  /* pixel/metre calibration */
  const ppm = CFG.PX_PER_METER || 300;
  const vxMs = vxPxPerSec / ppm;
  const vyMs = vyPxPerSec / ppm;
  const speedMs = Math.sqrt(vxMs*vxMs + vyMs*vyMs);

  /* angle — invert Y because screen Y goes down */
  const dx = fN.x - f0.x;
  const dy = -(fN.y - f0.y);
  const angleRad = Math.atan2(dy, dx);
  let angleDeg = angleRad * (180/Math.PI);
  angleDeg = Math.max(-90, Math.min(90, angleDeg));

  /* direction */
  const dir = angleDeg > 2 ? 'Right' : angleDeg < -2 ? 'Left' : 'Straight';

  /* lateral deviation in cm at 1m distance (angular) */
  const deviationCm = Math.tan(angleRad) * 100;

  setMetric('mSpeed',  `${speedMs.toFixed(2)} m/s`);
  setMetric('mAngle',  `${angleDeg.toFixed(1)}°`);
  setMetric('mDir',    dir);
  setMetric('mDev',    `${deviationCm >= 0 ? '+' : ''}${deviationCm.toFixed(1)} cm/m`);
  setMetric('mFrames', postFrames.length);
}

/* ─── DRAWING ─── */
let animId = null;
function renderLoop() {
  animId = requestAnimationFrame(renderLoop);
  if (!overlay.width) return;
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  /* Crosshairs */
  if (state !== S.IDLE) {
    ctx.strokeStyle = 'rgba(231,34,42,0.4)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8,5]);
    ctx.beginPath();
    ctx.moveTo(overlay.width/2,0); ctx.lineTo(overlay.width/2,overlay.height);
    ctx.moveTo(0,overlay.height/2); ctx.lineTo(overlay.width,overlay.height/2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  /* Locked ball indicator */
  if ((state===S.BALL_LOCKED||state===S.WAITING_BALL) && lockedPos && stableCount>=CFG.STABLE_FRAMES) {
    ctx.strokeStyle = '#ff9500';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(lockedPos.x, lockedPos.y, lockedPos.r+4, 0, Math.PI*2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,149,0,0.2)';
    ctx.fill();

    ctx.fillStyle = '#ff9500';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('BALL LOCKED', lockedPos.x, lockedPos.y - lockedPos.r - 14);
  }

  /* Post-impact trajectory */
  if (postFrames.length > 1) {
    /* trail line */
    ctx.strokeStyle = 'rgba(0,255,136,0.85)';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(postFrames[0].x, postFrames[0].y);
    for (let i=1;i<postFrames.length;i++) ctx.lineTo(postFrames[i].x,postFrames[i].y);
    ctx.stroke();

    /* draw each detected position */
    for (let i=0;i<postFrames.length;i++) {
      const f=postFrames[i];
      const alpha = 0.25 + 0.55*(i/postFrames.length);
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.strokeStyle = `rgba(200,255,200,${alpha})`;
      ctx.lineWidth = 1.5;
      ctx.fill(); ctx.stroke();

      /* centre dot */
      ctx.beginPath();
      ctx.arc(f.x, f.y, 3, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,255,136,0.95)';
      ctx.fill();
    }

    /* latest frame highlight */
    const lp = postFrames[postFrames.length-1];
    ctx.beginPath();
    ctx.arc(lp.x, lp.y, lp.r+6, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(0,255,136,1)';
    ctx.lineWidth = 2.5;
    ctx.stroke();

    /* direction arrow from start → end */
    if (state===S.DONE && postFrames.length>=2) {
      const p0=postFrames[0], p1=postFrames[postFrames.length-1];
      drawArrow(p0.x,p0.y,p1.x,p1.y,'rgba(255,255,100,0.8)');
    }
  }

  /* impact origin circle */
  if (postFrames.length>0 && lockedPos) {
    ctx.beginPath();
    ctx.arc(lockedPos.x, lockedPos.y, lockedPos.r+2, 0, Math.PI*2);
    ctx.strokeStyle='rgba(231,34,42,0.9)';
    ctx.lineWidth=2;
    ctx.stroke();
  }
}

function drawArrow(x1,y1,x2,y2,color) {
  const dx=x2-x1,dy=y2-y1;
  const len=Math.sqrt(dx*dx+dy*dy);
  if(len<10)return;
  const ux=dx/len,uy=dy/len;
  const hw=14, hl=24;
  ctx.save();
  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=3;
  ctx.beginPath();
  ctx.moveTo(x1,y1); ctx.lineTo(x2-ux*hl,y2-uy*hl);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-ux*hl-uy*hw, y2-uy*hl+ux*hw);
  ctx.lineTo(x2-ux*hl+uy*hw, y2-uy*hl-ux*hw);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

/* ─── RESET ─── */
function reset() {
  state = S.IDLE;
  if (loopId) {
    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) video.cancelVideoFrameCallback(loopId);
    else cancelAnimationFrame(loopId);
    loopId = null;
  }
  refFrame=null; preFrames=[]; postFrames=[];
  stableCount=0; lockedPos=null; lastPos=null; missedCount=0;
  CFG.PX_PER_METER = null;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  metrics.classList.remove('show');
  document.getElementById('btnRef').disabled   = false;
  document.getElementById('btnTrack').disabled = true;
  document.getElementById('btnReset').disabled = true;
  setStatus('Reset\nPress CAPTURE REFERENCE');
  toast('Reset — capture a new reference frame');
}

/* ─── EXPOSURE SLIDER ─── */
expSlider.addEventListener('input', () => {
  const ev = parseFloat(expSlider.value);
  applyExposure(ev);
});

/* ─── BUTTONS ─── */
document.getElementById('btnCamera').addEventListener('click', startCamera);
document.getElementById('btnRef').addEventListener('click', () => {
  captureReference();
  document.getElementById('btnRef').disabled = false; // keep available
});
document.getElementById('btnTrack').addEventListener('click', startTracking);
document.getElementById('btnReset').addEventListener('click', reset);

/* ─── BOOT ─── */
renderLoop();
</script>

</body>
</html>