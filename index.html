<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>Golf Ball Tracker</title>
<style>
:root {
  --black: #0c0c0c;
  --steel: #1f1f1f;
  --red: #e7222a;
  --darkred: #ba1e1e;
  --green: #00ff88;
  --orange: #ff9500;
  --safe-top:    env(safe-area-inset-top);
  --safe-bottom: env(safe-area-inset-bottom);
  --safe-left:   env(safe-area-inset-left);
  --safe-right:  env(safe-area-inset-right);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
background: var(–black);
color: #fff;
font-family: system-ui, -apple-system, sans-serif;
height: 100%;
overflow: hidden;
touch-action: manipulation;
-webkit-tap-highlight-color: transparent;
}

#wrap {
position: fixed;
inset: 0;
background: var(–black);
overflow: hidden;
}

/* ── VIDEO + CANVAS ── */
video, #overlay {
position: absolute;
inset: 0;
width: 100%;
height: 100%;
object-fit: cover;
}
#overlay { pointer-events: none; z-index: 2; }

/* ── STATUS BADGE (top-left) ── */
#statusBadge {
position: absolute;
top: calc(14px + var(–safe-top));
left: calc(14px + var(–safe-left));
background: rgba(20,20,20,0.92);
border: 1px solid rgba(255,255,255,0.1);
border-radius: 10px;
padding: 10px 14px;
font-size: 12px;
font-weight: 700;
white-space: pre-line;
line-height: 1.5;
z-index: 10;
max-width: 190px;
pointer-events: none;
}

/* ── METRICS PANEL (top-right) ── */
#metricsPanel {
position: absolute;
top: calc(14px + var(–safe-top));
right: calc(14px + var(–safe-right));
background: rgba(20,20,20,0.92);
border: 1px solid rgba(255,255,255,0.1);
border-radius: 10px;
padding: 12px 14px;
z-index: 10;
display: none;
min-width: 160px;
pointer-events: none;
}
#metricsPanel.show { display: block; }
.mrow {
display: flex;
justify-content: space-between;
align-items: baseline;
gap: 10px;
margin-bottom: 7px;
}
.mrow:last-child { margin-bottom: 0; }
.mlabel {
font-size: 9px;
font-weight: 800;
text-transform: uppercase;
letter-spacing: .12em;
color: rgba(255,255,255,0.5);
}
.mval {
font-size: 14px;
font-weight: 900;
font-variant-numeric: tabular-nums;
color: #fff;
}
.mval.green  { color: var(–green); }
.mval.orange { color: var(–orange); }

/* ── DETECTION BOX (DOM element, centred in the viewport) ── */
#detectionBox {
position: absolute;
width: 180px;
height: 180px;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
border: 2px dashed rgba(255,255,255,0.55);
border-radius: 12px;
z-index: 5;
pointer-events: none;
display: none;            /* shown by JS */
transition: border-color .3s, border-style .3s;
}
#detectionBox.detecting {
border-color: var(–red);
border-style: solid;
animation: pulseRed 1.5s ease-in-out infinite;
}
#detectionBox.locked {
border-color: var(–green);
border-style: solid;
animation: pulseGreen 2s ease-in-out infinite;
}
#boxLabel {
position: absolute;
top: -26px;
left: 50%;
transform: translateX(-50%);
font-size: 10px;
font-weight: 900;
letter-spacing: .14em;
text-transform: uppercase;
color: rgba(255,255,255,0.85);
white-space: nowrap;
}

@keyframes pulseRed {
0%,100% { box-shadow: 0 0 0 0 rgba(231,34,42,0.4); }
50%      { box-shadow: 0 0 18px 6px rgba(231,34,42,0.2); }
}
@keyframes pulseGreen {
0%,100% { box-shadow: 0 0 0 0 rgba(0,255,136,0.4); opacity:1; }
50%      { box-shadow: 0 0 18px 6px rgba(0,255,136,0.25); opacity:.85; }
}

/* ── EXPOSURE SLIDER (above buttons, hidden until camera on) ── */
#exposureRow {
position: absolute;
bottom: calc(252px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
display: none;
flex-direction: column;
align-items: center;
gap: 5px;
z-index: 20;
background: rgba(20,20,20,0.9);
border: 1px solid rgba(255,255,255,.1);
border-radius: 12px;
padding: 10px 18px;
width: 260px;
}
#exposureRow.show { display: flex; }
#exposureRow label {
font-size: 10px;
font-weight: 800;
text-transform: uppercase;
letter-spacing: .1em;
color: rgba(255,255,255,.55);
}
#expSlider { width: 100%; accent-color: var(–red); }
#expVal {
font-size: 11px;
font-weight: 800;
color: var(–orange);
}

/* ── BUTTON STACK ── */
/*  All buttons centred horizontally, spaced 56px apart from the bottom  */
.btn {
position: absolute;
left: 50%;
transform: translateX(-50%);
border: none;
font-size: 14px;
font-weight: 800;
letter-spacing: .5px;
text-transform: uppercase;
padding: 14px 32px;
border-radius: 999px;
cursor: pointer;
z-index: 30;
pointer-events: auto;
transition: opacity .15s, transform .15s;
white-space: nowrap;
min-width: 200px;
text-align: center;
}
.btn:active:not(:disabled) { transform: translateX(-50%) scale(0.97); }
.btn:disabled { opacity: .35; cursor: not-allowed; }

.btn-primary {
background: linear-gradient(135deg, var(–red), var(–darkred));
color: #fff;
box-shadow: 0 4px 20px rgba(231,34,42,.4);
}
.btn-secondary {
background: rgba(30,30,30,0.92);
border: 1px solid rgba(255,255,255,.14);
color: #fff;
}

/* Individual button positions — clear 56px gaps */
#btnCamera  { bottom: calc(20px  + var(–safe-bottom)); }
#btnRef     { bottom: calc(84px  + var(–safe-bottom)); }
#btnTrack   { bottom: calc(148px + var(–safe-bottom)); }
#btnReset   { bottom: calc(212px + var(–safe-bottom)); }

/* ── DARK WARNING ── */
#darkWarn {
position: absolute;
bottom: calc(280px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
background: rgba(255,149,0,.15);
border: 1px solid var(–orange);
border-radius: 8px;
padding: 7px 14px;
font-size: 11px;
font-weight: 700;
color: var(–orange);
z-index: 20;
display: none;
white-space: nowrap;
pointer-events: none;
}
#darkWarn.show { display: block; }

/* ── TOAST ── */
.toast {
position: fixed;
bottom: calc(310px + var(–safe-bottom));
left: 50%;
transform: translateX(-50%);
background: rgba(20,20,20,.96);
border: 1px solid var(–red);
border-radius: 10px;
padding: 10px 18px;
font-size: 13px;
font-weight: 700;
z-index: 100;
pointer-events: none;
animation: slideUp .25s ease-out;
white-space: nowrap;
}
@keyframes slideUp {
from { opacity:0; transform: translate(-50%,12px); }
to   { opacity:1; transform: translate(-50%,0); }
}
</style>

</head>
<body>
<div id="wrap">
  <video id="video" playsinline autoplay muted></video>
  <canvas id="overlay"></canvas>

  <!-- Detection box (shown after camera starts) -->

  <div id="detectionBox">
    <div id="boxLabel">BALL AREA</div>
  </div>

  <!-- Status top-left -->

  <div id="statusBadge">Press START CAMERA</div>

  <!-- Metrics top-right (hidden until tracking) -->

  <div id="metricsPanel">
    <div class="mrow"><span class="mlabel">FRAMES</span>   <span class="mval"        id="mFrames">0</span></div>
    <div class="mrow"><span class="mlabel">BALL SPEED</span><span class="mval green"  id="mSpeed">--</span></div>
    <div class="mrow"><span class="mlabel">ANGLE</span>     <span class="mval"        id="mAngle">--</span></div>
    <div class="mrow"><span class="mlabel">DIRECTION</span> <span class="mval orange" id="mDir">--</span></div>
    <div class="mrow"><span class="mlabel">DEVIATION</span> <span class="mval"        id="mDev">--</span></div>
  </div>

  <!-- Exposure slider (hidden until camera starts) -->

  <div id="exposureRow">
    <label>Shutter Speed (Exposure)</label>
    <input id="expSlider" type="range" min="-3" max="0" step="0.25" value="-2"/>
    <span id="expVal">-2.0 EV — fast shutter ✓</span>
  </div>

  <!-- Dark frame warning -->

  <div id="darkWarn">⚠️ Too dark — add more light</div>

  <!-- Button stack — 4 buttons, 56px apart -->

<button class="btn btn-primary"   id="btnCamera">START CAMERA</button>
<button class="btn btn-secondary" id="btnRef"    disabled>CAPTURE REFERENCE</button>
<button class="btn btn-secondary" id="btnTrack"  disabled>START TRACKING</button>
<button class="btn btn-secondary" id="btnReset"  disabled>RESET</button>

</div>

<script>
/* ══════════════════════════════════════════
   KEY TECHNIQUE: Very high shutter speed
   (low exposure EV) freezes the ball as a
   crisp circle in each 60fps frame.
   Without this, fast balls blur into smears
   that fail the circularity check.

   Side-effect: darker image — needs bright
   LED lighting for best results.
══════════════════════════════════════════ */

/* ─── CONFIG ─── */
const CFG = {
  DIFF_THR:         25,
  MIN_BLOB:          8,
  MAX_BLOB:       3000,
  MIN_R_PX:          5,
  MAX_R_PX:         80,
  MAX_ASPECT:      1.8,
  STEP:              2,
  STABLE_FRAMES:     6,
  STABLE_THRESH:     4,
  IMPACT_THRESH:    18,
  MAX_POST_FRAMES:  12,
  MAX_MISSED:        4,
  SEARCH_RADIUS:   350,
  PX_PER_METER:   null,
  BALL_DIAM_M:  0.0427,
};

/* ─── STATES ─── */
const S = { IDLE:0, WAITING:1, LOCKED:2, TRACKING:3, DONE:4 };
let state = S.IDLE;

/* ─── RUNTIME ─── */
let refFrame   = null;
let preFrames  = [];
let postFrames = [];
let stableCount= 0;
let lockedPos  = null;
let lastPos    = null;
let missedCount= 0;
let loopId     = null;
let imageCapture = null;
let exposureEV   = -2.0;

/* ─── DOM ─── */
const video    = document.getElementById('video');
const overlay  = document.getElementById('overlay');
const ctx      = overlay.getContext('2d', {willReadFrequently:true});
const offscreen= document.createElement('canvas');
const offCtx   = offscreen.getContext('2d', {willReadFrequently:true});
const detBox   = document.getElementById('detectionBox');
const statusEl = document.getElementById('statusBadge');
const metricsEl= document.getElementById('metricsPanel');
const darkWarn = document.getElementById('darkWarn');
const expRow   = document.getElementById('exposureRow');
const expSlider= document.getElementById('expSlider');
const expValEl = document.getElementById('expVal');

/* ─── HELPERS ─── */
function toast(msg) {
  document.querySelectorAll('.toast').forEach(e => e.remove());
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  document.body.appendChild(t);
  setTimeout(() => t.remove(), 3000);
}
function setStatus(t)       { statusEl.textContent = t; }
function setMetric(id, v)   { document.getElementById(id).textContent = v; }
function showMetrics()       { metricsEl.classList.add('show'); }
function hideMetrics()       { metricsEl.classList.remove('show'); }

/* ─── DETECTION BOX HELPERS ─── */
function showBox(state) {
  detBox.style.display = 'block';
  detBox.className = '';             // clear
  if (state === 'detecting') detBox.classList.add('detecting');
  if (state === 'locked')    detBox.classList.add('locked');
  document.getElementById('boxLabel').textContent =
    state === 'locked' ? 'BALL LOCKED ✓' : 'BALL AREA';
}
function hideBox() { detBox.style.display = 'none'; }

/* ─── GET BOX RECT IN VIDEO COORDS ─── */
function getBoxVideoRect() {
  const vr = video.getBoundingClientRect();
  const br = detBox.getBoundingClientRect();
  const sx = video.videoWidth  / vr.width;
  const sy = video.videoHeight / vr.height;
  return {
    x: (br.left - vr.left) * sx,
    y: (br.top  - vr.top)  * sy,
    w: br.width  * sx,
    h: br.height * sy,
  };
}

/* ─── IS WHITE PIXEL ─── */
function isWhite(r, g, b) {
  const lum = r*0.299 + g*0.587 + b*0.114;
  if (lum < 140) return false;
  if (Math.max(r,g,b) - Math.min(r,g,b) > 45) return false;
  return true;
}

/* ─── GRAB FRAME ─── */
function grabFrame() {
  offCtx.drawImage(video, 0, 0);
  return offCtx.getImageData(0, 0, offscreen.width, offscreen.height);
}

/* ─── BRIGHTNESS CHECK ─── */
function checkBrightness(frame) {
  let sum = 0, n = 0;
  for (let i = 0; i < frame.data.length; i += 80) {
    sum += (frame.data[i] + frame.data[i+1] + frame.data[i+2]) / 3;
    n++;
  }
  const avg = sum / n;
  darkWarn.classList.toggle('show', avg < 30);
  return avg;
}

/* ─── BLOB DETECTOR ─── */
function findBall(ref, cur, x0, x1, y0, y1, hint) {
  const W = cur.width;
  const step = CFG.STEP;
  x0 = Math.max(0, x0|0);  x1 = Math.min(W, x1|0);
  y0 = Math.max(0, y0|0);  y1 = Math.min(cur.height, y1|0);
  const gw = Math.max(1, ((x1-x0)/step)|0);
  const gh = Math.max(1, ((y1-y0)/step)|0);
  const grid = new Uint8Array(gw * gh);

  let idx = 0;
  for (let gy = 0; gy < gh; gy++) {
    const ay = y0 + gy*step;
    for (let gx = 0; gx < gw; gx++, idx++) {
      const ax = x0 + gx*step;
      const fi = (ay*W + ax)*4;
      const cr=cur.data[fi], cg=cur.data[fi+1], cb=cur.data[fi+2];
      const d = (Math.abs(cr-ref.data[fi]) + Math.abs(cg-ref.data[fi+1]) + Math.abs(cb-ref.data[fi+2])) / 3;
      if (d > CFG.DIFF_THR && isWhite(cr,cg,cb)) grid[idx] = 1;
    }
  }

  const vis = new Uint8Array(gw*gh);
  let best = null, bestScore = 0;

  for (let i = 0; i < grid.length; i++) {
    if (!grid[i] || vis[i]) continue;
    const q=[i]; vis[i]=1; const comp=[];
    for (let qi=0; qi<q.length; qi++) {
      const c=q[qi]; comp.push(c);
      const gx=c%gw, gy=(c/gw)|0;
      const ns=[c-1,c+1,c-gw,c+gw];
      const ok=[gx>0, gx<gw-1, gy>0, gy<gh-1];
      for (let n=0;n<4;n++) if(ok[n]&&grid[ns[n]]&&!vis[ns[n]]){vis[ns[n]]=1;q.push(ns[n]);}
    }
    if (comp.length < CFG.MIN_BLOB || comp.length > CFG.MAX_BLOB) continue;

    let sx=0,sy=0,mnx=Infinity,mxx=-Infinity,mny=Infinity,mxy=-Infinity;
    for (const c of comp) {
      const gx=c%gw, gy=(c/gw)|0;
      sx+=gx; sy+=gy;
      if(gx<mnx)mnx=gx; if(gx>mxx)mxx=gx;
      if(gy<mny)mny=gy; if(gy>mxy)mxy=gy;
    }
    const cx = x0 + (sx/comp.length)*step;
    const cy = y0 + (sy/comp.length)*step;
    const bw = (mxx-mnx+1)*step, bh = (mxy-mny+1)*step;
    const radius = Math.max(bw,bh)/2;
    if (radius < CFG.MIN_R_PX || radius > CFG.MAX_R_PX) continue;
    if ((bw>=bh?bw/bh:bh/bw) > CFG.MAX_ASPECT) continue;

    let score = comp.length * (comp.length/(bw*bh));
    if (hint) {
      const dx=cx-hint.x, dy=cy-hint.y;
      score /= (1 + Math.sqrt(dx*dx+dy*dy)*0.015);
      if (hint.r) score /= (1 + Math.abs(radius-hint.r)*0.08);
    }
    if (score > bestScore) { bestScore=score; best={x:cx,y:cy,r:radius}; }
  }
  return best;
}

/* ─── EXPOSURE CONTROL ─── */
async function applyExposure(ev) {
  exposureEV = ev;
  expValEl.textContent = `${ev.toFixed(2)} EV${ev <= -1.5 ? ' — fast shutter ✓' : ''}`;
  try {
    const track = video.srcObject?.getVideoTracks()[0];
    if (track?.applyConstraints) {
      await track.applyConstraints({ advanced: [{ exposureCompensation: ev }] });
    }
    if (imageCapture) {
      const caps = await imageCapture.getPhotoCapabilities().catch(()=>null);
      if (caps?.exposureCompensation) {
        const {min,max} = caps.exposureCompensation;
        const mapped = min + ((ev+3)/3)*(max-min);
        await imageCapture.setOptions({ exposureCompensation: Math.max(min,Math.min(max,mapped)) });
      }
    }
  } catch(e) { /* silent */ }
}

/* ─── CAMERA START ─── */
async function startCamera() {
  try {
    const perm = await navigator.mediaDevices.getUserMedia({video:true});
    perm.getTracks().forEach(t=>t.stop());

    const devices = await navigator.mediaDevices.enumerateDevices();
    const cams = devices.filter(d=>d.kind==='videoinput');
    const back = cams.find(d=>/back|rear|environment/i.test(d.label));
    const usb  = cams.find(d=>/usb|uvc|capture|hdmi|elgato/i.test(d.label));
    const deviceId = (usb||back)?.deviceId;

    const stream = await navigator.mediaDevices.getUserMedia({ video: {
      ...(deviceId ? {deviceId:{exact:deviceId}} : {facingMode:{ideal:'environment'}}),
      width:  {ideal:1920}, height: {ideal:1080}, frameRate: {ideal:60},
      exposureMode: 'manual',
      exposureCompensation: {ideal: -2.0},
      whiteBalanceMode: 'continuous',
    }});

    video.srcObject = stream;
    await video.play();
    await new Promise(r => { if(video.videoWidth) return r(); video.addEventListener('loadedmetadata',r,{once:true}); });

    overlay.width = offscreen.width  = video.videoWidth;
    overlay.height= offscreen.height = video.videoHeight;

    const track = stream.getVideoTracks()[0];
    if (window.ImageCapture) imageCapture = new ImageCapture(track);

    const s = track.getSettings();
    setStatus(`Camera ready\n${s.frameRate|0}fps · ${video.videoWidth}×${video.videoHeight}`);
    document.getElementById('btnCamera').disabled = true;
    document.getElementById('btnRef').disabled    = false;

    /* Show box + exposure slider, hide the camera button */
    showBox('detecting');
    expRow.classList.add('show');

    applyExposure(-2.0);
    toast('Camera started');

  } catch(err) {
    setStatus('Camera error:\n'+err.message);
    toast('Camera failed: '+err.message);
  }
}

/* ─── CAPTURE REFERENCE ─── */
function captureReference() {
  refFrame = grabFrame();
  checkBrightness(refFrame);
  state = S.WAITING;
  preFrames=[]; postFrames=[];
  stableCount=0; lockedPos=null;
  showBox('detecting');
  setStatus('Reference captured\nPlace ball in the box');
  document.getElementById('btnTrack').disabled = false;
  document.getElementById('btnReset').disabled = false;
  toast('Reference captured — place ball & press START TRACKING');
}

/* ─── START TRACKING ─── */
function startTracking() {
  if (!refFrame) return;
  state = S.WAITING;
  preFrames=[]; postFrames=[];
  stableCount=0; lockedPos=null; lastPos=null; missedCount=0;
  CFG.PX_PER_METER = null;
  showMetrics();
  showBox('detecting');
  document.getElementById('btnTrack').disabled = true;
  document.getElementById('btnRef').disabled   = true;
  setStatus('Waiting for ball...\nPlace ball in box');
  setMetric('mFrames','0'); setMetric('mSpeed','--');
  setMetric('mAngle','--'); setMetric('mDir','--'); setMetric('mDev','--');
  scheduleNext();
}

/* ─── LOOP ─── */
function scheduleNext() {
  if (state===S.IDLE || state===S.DONE) return;
  if ('requestVideoFrameCallback' in HTMLVideoElement.prototype)
    loopId = video.requestVideoFrameCallback(onFrame);
  else
    loopId = requestAnimationFrame(onFrame);
}

function onFrame() {
  if (state===S.IDLE || state===S.DONE) return;
  processFrame();
  scheduleNext();
}

/* ─── PROCESS FRAME ─── */
function processFrame() {
  if (!refFrame) return;
  const cur = grabFrame();
  checkBrightness(cur);
  const W = cur.width, H = cur.height;
  const t = performance.now();

  /* ── PRE-IMPACT: find + stabilise ball in box ── */
  if (state === S.WAITING || state === S.LOCKED) {
    const box = getBoxVideoRect();
    const ball = findBall(refFrame, cur, box.x, box.x+box.w, box.y, box.y+box.h, lockedPos);

    if (ball) {
      if (lockedPos) {
        const dx=ball.x-lockedPos.x, dy=ball.y-lockedPos.y;
        const moved = Math.sqrt(dx*dx+dy*dy);

        if (moved < CFG.STABLE_THRESH) {
          stableCount++;
        } else if (moved > CFG.IMPACT_THRESH && stableCount >= CFG.STABLE_FRAMES) {
          /* ─── IMPACT DETECTED ─── */
          state = S.TRACKING;
          postFrames = [{x:ball.x, y:ball.y, r:ball.r, t}];
          lastPos = ball;
          missedCount = 0;
          showBox('locked');
          setStatus('Impact! Tracking...');
          setMetric('mFrames','1');
          toast('Impact detected!');
          if (!CFG.PX_PER_METER && lockedPos)
            CFG.PX_PER_METER = (lockedPos.r*2) / CFG.BALL_DIAM_M;
          return;
        } else {
          stableCount = Math.max(0, stableCount-1);
        }
      }

      lockedPos = ball;
      preFrames.push({x:ball.x,y:ball.y,r:ball.r,t});
      if (preFrames.length > 30) preFrames.shift();

      if (stableCount >= CFG.STABLE_FRAMES) {
        state = S.LOCKED;
        showBox('locked');
        setStatus(`Ball locked ✓\nReady to hit!`);
      } else {
        showBox('detecting');
        setStatus(`Stabilising...\n${stableCount}/${CFG.STABLE_FRAMES}`);
      }
    } else {
      stableCount = 0;
      setStatus('No ball detected\nPlace white ball in box');
    }

  /* ── POST-IMPACT: track across full frame ── */
  } else if (state === S.TRACKING) {
    const sr = CFG.SEARCH_RADIUS;
    const x0 = lastPos ? lastPos.x-sr : 0;
    const x1 = lastPos ? lastPos.x+sr : W;
    const y0 = lastPos ? lastPos.y-sr : 0;
    const y1 = lastPos ? lastPos.y+sr : H;
    const ball = findBall(refFrame, cur, x0, x1, y0, y1, lastPos);

    if (ball) {
      missedCount = 0;
      lastPos = ball;
      postFrames.push({x:ball.x,y:ball.y,r:ball.r,t});
      setMetric('mFrames', postFrames.length);
      if (postFrames.length >= 2) calcMetrics();
    } else {
      if (++missedCount > CFG.MAX_MISSED) { finishTracking(); return; }
    }
    if (postFrames.length >= CFG.MAX_POST_FRAMES) finishTracking();
  }
}

/* ─── FINISH ─── */
function finishTracking() {
  state = S.DONE;
  calcMetrics();
  setStatus(`Done — ${postFrames.length} frames\nRESET for next shot`);
  showBox('locked');
  document.getElementById('btnRef').disabled = false;
  toast('Shot tracked! ✓');
}

/* ─── METRICS ─── */
function calcMetrics() {
  if (postFrames.length < 2) return;
  const n=postFrames.length, t0=postFrames[0].t;
  let st=0,sx=0,sy=0,st2=0,stx=0,sty=0;
  for (const f of postFrames) {
    const dt=(f.t-t0)/1000;
    st+=dt;sx+=f.x;sy+=f.y;st2+=dt*dt;stx+=dt*f.x;sty+=dt*f.y;
  }
  const den=n*st2-st*st;
  let vx=0,vy=0;
  if (Math.abs(den)>1e-9) { vx=(n*stx-st*sx)/den; vy=(n*sty-st*sy)/den; }

  const ppm = CFG.PX_PER_METER || 300;
  const spd = Math.sqrt((vx/ppm)**2 + (vy/ppm)**2);

  const f0=postFrames[0], fN=postFrames[n-1];
  const dx=fN.x-f0.x, dy=-(fN.y-f0.y);
  const ang = Math.atan2(dy,dx)*(180/Math.PI);
  const clamped = Math.max(-90,Math.min(90,ang));
  const dir = clamped>2?'Right':clamped<-2?'Left':'Straight';
  const dev = Math.tan(ang*Math.PI/180)*100;

  setMetric('mSpeed',  `${spd.toFixed(2)} m/s`);
  setMetric('mAngle',  `${clamped.toFixed(1)}°`);
  setMetric('mDir',    dir);
  setMetric('mDev',    `${dev>=0?'+':''}${dev.toFixed(1)} cm/m`);
  setMetric('mFrames', n);
}

/* ─── RENDER LOOP ─── */
function renderLoop() {
  requestAnimationFrame(renderLoop);
  if (!overlay.width) return;
  ctx.clearRect(0,0,overlay.width,overlay.height);

  /* ROI horizontal strip (shown once tracking starts) */
  if (state === S.TRACKING || state === S.DONE) {
    const W=overlay.width, H=overlay.height;
    const stripH = H * 0.35;
    const top    = (H-stripH)/2;
    const bot    = top+stripH;

    /* shaded area above + below the strip */
    ctx.fillStyle = 'rgba(0,0,0,0.30)';
    ctx.fillRect(0, 0, W, top);
    ctx.fillRect(0, bot, W, H-bot);

    /* dashed boundary lines */
    ctx.strokeStyle = 'rgba(0,255,100,0.55)';
    ctx.lineWidth = 2;
    ctx.setLineDash([12,6]);
    ctx.beginPath(); ctx.moveTo(0,top); ctx.lineTo(W,top); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,bot); ctx.lineTo(W,bot); ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(0,255,100,0.8)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('TRACKING ZONE', 14, top-8);
  }

  /* Crosshairs */
  if (state !== S.IDLE) {
    ctx.strokeStyle = 'rgba(231,34,42,0.35)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8,5]);
    ctx.beginPath();
    ctx.moveTo(overlay.width/2,0); ctx.lineTo(overlay.width/2,overlay.height);
    ctx.moveTo(0,overlay.height/2); ctx.lineTo(overlay.width,overlay.height/2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  /* Locked ball ring (pre-impact) */
  if ((state===S.LOCKED||state===S.WAITING) && lockedPos && stableCount>=CFG.STABLE_FRAMES) {
    ctx.strokeStyle = 'rgba(255,149,0,0.95)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(lockedPos.x, lockedPos.y, lockedPos.r+5, 0, Math.PI*2);
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,149,0,0.15)';
    ctx.fill();
  }

  /* Post-impact trajectory */
  if (postFrames.length > 1) {
    ctx.strokeStyle = 'rgba(0,255,136,0.9)';
    ctx.lineWidth = 4;
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(postFrames[0].x, postFrames[0].y);
    for (let i=1;i<postFrames.length;i++) ctx.lineTo(postFrames[i].x,postFrames[i].y);
    ctx.stroke();

    for (let i=0;i<postFrames.length;i++) {
      const f=postFrames[i];
      const a=0.25+0.55*(i/postFrames.length);
      ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
      ctx.fillStyle=`rgba(255,255,255,${a})`;
      ctx.strokeStyle=`rgba(200,255,200,${a})`;
      ctx.lineWidth=1.5; ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(f.x,f.y,3,0,Math.PI*2);
      ctx.fillStyle='rgba(0,255,136,0.95)'; ctx.fill();
    }

    const lp=postFrames[postFrames.length-1];
    ctx.beginPath(); ctx.arc(lp.x,lp.y,lp.r+6,0,Math.PI*2);
    ctx.strokeStyle='rgba(0,255,136,1)'; ctx.lineWidth=2.5; ctx.stroke();

    if (state===S.DONE && postFrames.length>=2) {
      const p0=postFrames[0],p1=postFrames[postFrames.length-1];
      drawArrow(p0.x,p0.y,p1.x,p1.y,'rgba(255,255,100,0.85)');
    }
  }

  /* Impact origin marker */
  if (postFrames.length>0 && lockedPos) {
    ctx.beginPath(); ctx.arc(lockedPos.x,lockedPos.y,lockedPos.r+2,0,Math.PI*2);
    ctx.strokeStyle='rgba(231,34,42,0.9)'; ctx.lineWidth=2; ctx.stroke();
  }
}

function drawArrow(x1,y1,x2,y2,color) {
  const dx=x2-x1,dy=y2-y1,len=Math.sqrt(dx*dx+dy*dy);
  if(len<10)return;
  const ux=dx/len,uy=dy/len,hw=14,hl=24;
  ctx.save();
  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2-ux*hl,y2-uy*hl); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2-ux*hl-uy*hw, y2-uy*hl+ux*hw);
  ctx.lineTo(x2-ux*hl+uy*hw, y2-uy*hl-ux*hw);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

/* ─── RESET ─── */
function reset() {
  state = S.IDLE;
  if (loopId) {
    if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) video.cancelVideoFrameCallback(loopId);
    else cancelAnimationFrame(loopId);
    loopId = null;
  }
  refFrame=null; preFrames=[]; postFrames=[];
  stableCount=0; lockedPos=null; lastPos=null; missedCount=0;
  CFG.PX_PER_METER=null;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  hideMetrics();
  showBox('detecting');
  document.getElementById('btnRef').disabled   = false;
  document.getElementById('btnTrack').disabled = true;
  document.getElementById('btnReset').disabled = true;
  setStatus('Ready\nPress CAPTURE REFERENCE');
  toast('Reset complete');
}

/* ─── EVENTS ─── */
expSlider.addEventListener('input', () => applyExposure(parseFloat(expSlider.value)));
document.getElementById('btnCamera').addEventListener('click', startCamera);
document.getElementById('btnRef').addEventListener('click', captureReference);
document.getElementById('btnTrack').addEventListener('click', startTracking);
document.getElementById('btnReset').addEventListener('click', reset);

/* ─── BOOT ─── */
renderLoop();
</script>

</body>
</html>